// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: records.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createRecord = `-- name: CreateRecord :one
INSERT INTO records (created_by, created_user_agent, created_client_ip, type, store_id, record_id, user_id, device_id, from_online_payment, amount, point_amount, ts)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
ON CONFLICT (store_id, record_id) DO NOTHING
RETURNING created_by, created_user_agent, created_client_ip, type, store_id, record_id, user_id, device_id, from_online_payment, amount, point_amount, ts, created_at
`

type CreateRecordParams struct {
	CreatedBy         uuid.NullUUID
	CreatedUserAgent  sql.NullString
	CreatedClientIp   sql.NullString
	Type              string
	StoreID           uuid.UUID
	RecordID          sql.NullString
	UserID            uuid.NullUUID
	DeviceID          sql.NullString
	FromOnlinePayment sql.NullString
	Amount            int32
	PointAmount       sql.NullInt32
	Ts                int64
}

func (q *Queries) CreateRecord(ctx context.Context, arg CreateRecordParams) (Record, error) {
	row := q.db.QueryRowContext(ctx, createRecord,
		arg.CreatedBy,
		arg.CreatedUserAgent,
		arg.CreatedClientIp,
		arg.Type,
		arg.StoreID,
		arg.RecordID,
		arg.UserID,
		arg.DeviceID,
		arg.FromOnlinePayment,
		arg.Amount,
		arg.PointAmount,
		arg.Ts,
	)
	var i Record
	err := row.Scan(
		&i.CreatedBy,
		&i.CreatedUserAgent,
		&i.CreatedClientIp,
		&i.Type,
		&i.StoreID,
		&i.RecordID,
		&i.UserID,
		&i.DeviceID,
		&i.FromOnlinePayment,
		&i.Amount,
		&i.PointAmount,
		&i.Ts,
		&i.CreatedAt,
	)
	return i, err
}

const getStoreDeviceRecords = `-- name: GetStoreDeviceRecords :many
SELECT r.type, r.user_id, u.name AS user_name, r.amount, r.point_amount, r.ts
FROM records AS r LEFT JOIN users AS u ON r.user_id = u.id
WHERE r.store_id = $1 AND r.device_id = $2::TEXT
ORDER BY r.ts DESC
`

type GetStoreDeviceRecordsParams struct {
	StoreID  uuid.UUID
	DeviceID string
}

type GetStoreDeviceRecordsRow struct {
	Type        string
	UserID      uuid.NullUUID
	UserName    sql.NullString
	Amount      int32
	PointAmount sql.NullInt32
	Ts          int64
}

func (q *Queries) GetStoreDeviceRecords(ctx context.Context, arg GetStoreDeviceRecordsParams) ([]GetStoreDeviceRecordsRow, error) {
	rows, err := q.db.QueryContext(ctx, getStoreDeviceRecords, arg.StoreID, arg.DeviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStoreDeviceRecordsRow{}
	for rows.Next() {
		var i GetStoreDeviceRecordsRow
		if err := rows.Scan(
			&i.Type,
			&i.UserID,
			&i.UserName,
			&i.Amount,
			&i.PointAmount,
			&i.Ts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoreUserRecords = `-- name: GetStoreUserRecords :many
SELECT
  r.type,
  r.created_by AS created_by_user_id,
  u1.name AS created_by_user_name,
  r.user_id AS user_id,
  u2.name AS user_name,
  r.device_id,
  sd.name AS device_name,
  sd.real_type AS device_real_type,
  sd.display_type AS device_display_type,
  r.from_online_payment,
  r.amount,
  r.point_amount,
  r.ts
FROM records AS r
LEFT JOIN store_devices AS sd ON r.device_id = sd.device_id AND r.store_id = sd.store_id
LEFT JOIN users AS u1 ON r.created_by = u1.id
LEFT JOIN users AS u2 ON r.user_id = u2.id
WHERE (
  r.user_id = $2::UUID OR
  r.created_by = $2::UUID
) AND r.type = ANY($3::TEXT[]) AND r.store_id = $1
ORDER BY r.ts DESC
`

type GetStoreUserRecordsParams struct {
	StoreID uuid.UUID
	UserID  uuid.UUID
	Types   []string
}

type GetStoreUserRecordsRow struct {
	Type              string
	CreatedByUserID   uuid.NullUUID
	CreatedByUserName sql.NullString
	UserID            uuid.NullUUID
	UserName          sql.NullString
	DeviceID          sql.NullString
	DeviceName        sql.NullString
	DeviceRealType    sql.NullString
	DeviceDisplayType sql.NullString
	FromOnlinePayment sql.NullString
	Amount            int32
	PointAmount       sql.NullInt32
	Ts                int64
}

func (q *Queries) GetStoreUserRecords(ctx context.Context, arg GetStoreUserRecordsParams) ([]GetStoreUserRecordsRow, error) {
	rows, err := q.db.QueryContext(ctx, getStoreUserRecords, arg.StoreID, arg.UserID, pq.Array(arg.Types))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStoreUserRecordsRow{}
	for rows.Next() {
		var i GetStoreUserRecordsRow
		if err := rows.Scan(
			&i.Type,
			&i.CreatedByUserID,
			&i.CreatedByUserName,
			&i.UserID,
			&i.UserName,
			&i.DeviceID,
			&i.DeviceName,
			&i.DeviceRealType,
			&i.DeviceDisplayType,
			&i.FromOnlinePayment,
			&i.Amount,
			&i.PointAmount,
			&i.Ts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
